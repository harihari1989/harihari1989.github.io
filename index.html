<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Matrix Background</title>
  <style>
    body {
      background-color: #000;
      margin: 0;
      overflow: hidden;
    }

    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="matrix"></canvas>

  <script>
    // Matrix pixel settings
    var symbolSize = 20; // Size of each symbol/pixel
    var streamLength = 30; // Number of streams/pixel columns
    var symbolSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; // Set of symbols

    var canvas = document.getElementById("matrix");
    var context = canvas.getContext("2d");

    // Set canvas size to fill the whole window
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Calculate the number of columns based on the canvas width and symbol size
    var columns = Math.ceil(canvas.width / symbolSize);

    // Create an array to hold the streams
    var streams = [];

    // Create symbol objects for each column
    for (var i = 0; i < columns; i++) {
      var stream = new Stream(i * symbolSize);
      stream.generateSymbols();
      streams.push(stream);
    }

    // Function to update and render the symbol streams
    function update() {
      context.clearRect(0, 0, canvas.width, canvas.height);

      streams.forEach(function(stream) {
        stream.render();
      });

      requestAnimationFrame(update);
    }

    // Symbol object
    function Symbol(x, y, speed, first) {
      this.x = x;
      this.y = y;
      this.value;
      this.speed = speed;
      this.first = first;

      this.switchInterval = Math.floor(Math.random() * 20) + 10;

      // Set a random symbol
      this.setRandomSymbol = function() {
        if (frameCount % this.switchInterval == 0) {
          this.value = symbolSet[Math.floor(Math.random() * symbolSet.length)];
        }
      }

      // Update the symbol position
      this.update = function() {
        if (this.y >= canvas.height) {
          this.y = 0;
        } else {
          this.y += this.speed;
        }
      }
    }

    // Stream object
    function Stream(x) {
      this.symbols = [];
      this.totalSymbols = Math.floor(Math.random() * (streamLength - 10)) + 10;
      this.speed = Math.random() * 5 + 1;

      // Generate symbols for the stream
      this.generateSymbols = function() {
        var y = 0;
        var first = true;

        for (var i = 0; i <= this.totalSymbols; i++) {
          var symbol = new Symbol(x, y, this.speed, first);
          symbol.setRandomSymbol();
          this.symbols.push(symbol);

          y -= symbolSize;
          first = false;
        }
      }

      // Render the symbols in the stream
      this.render = function() {
        this.symbols.forEach(function(symbol) {
          if (symbol.first) {
            context.fillStyle = "#33ff33";
          } else {
            context.fillStyle = "#00ff00";
          }
          context.fillText(symbol.value, symbol.x, symbol.y);
          symbol.update();
          symbol.setRandomSymbol();
        });
      }
    }

    // Start the animation
    update();
  </script>
</body>
</html>
